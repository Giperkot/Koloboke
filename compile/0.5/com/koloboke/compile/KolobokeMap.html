<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_74) on Wed May 25 17:45:12 BST 2016 -->
<title>KolobokeMap (Koloboke Compile Annotations 0.5)</title>
<meta name="date" content="2016-05-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KolobokeMap (Koloboke Compile Annotations 0.5)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/KolobokeMap.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../com/koloboke/compile/CustomKeyEquivalence.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../com/koloboke/compile/KolobokeSet.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/koloboke/compile/KolobokeMap.html" target="_top">Frames</a></li>
<li><a href="KolobokeMap.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li>Optional</li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Element</li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.koloboke.compile</div>
<h2 title="Annotation Type KolobokeMap" class="title">Annotation Type KolobokeMap</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true" title="class or interface in java.lang.annotation">@Retention</a>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true#value--" title="class or interface in java.lang.annotation">value</a>=<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html?is-external=true#SOURCE" title="class or interface in java.lang.annotation">SOURCE</a>)
 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true" title="class or interface in java.lang.annotation">@Target</a>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true#value--" title="class or interface in java.lang.annotation">value</a>=<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#TYPE" title="class or interface in java.lang.annotation">TYPE</a>)
public @interface <span class="memberNameLabel">KolobokeMap</span></pre>
<div class="block">Specifies that Koloboke Compile should generate an implementation of the annotated <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</a>-like class or interface.

 <h3>Requirements and permissions for <code>@KolobokeMap</code>-annotated types</h3>
 <h4><i><code>Map</code> model defining</i> method forms</h4>
 <p>The annotated type must have at least one abstract method (either declared in the body of the
 type or inherited) <i>matching</i> (see below) some form from the following list:
 <table BORDER CELLPADDING=3 CELLSPACING=1 summary="Map input method forms">
     <tr><th>Return type</th><th>Signature</th><th>Notes</th></tr>
     <tr><td ALIGN=RIGHT><code>ValueType</code></td>
         <td><code>put(KeyType key, ValueType value)</code></td><td></td></tr>
     <tr><td ALIGN=RIGHT><code>ValueType</code></td>
         <td><code>putIfAbsent(KeyType key, ValueType value)</code></td><td></td></tr>
     <tr><td ALIGN=RIGHT><code>ValueType</code></td>
         <td><code>replace(KeyType key, ValueType value)</code></td><td></td></tr>
     <tr><td ALIGN=RIGHT><code>boolean</code></td>
         <td><code>replace(KeyType key, ValueType oldValue, ValueType newValue)</code></td><td></td>
         </tr>
     <tr><td ALIGN=RIGHT><code>void</code></td>
         <td><code>justPut(KeyType key, ValueType value)</code></td>
         <td>Semantically equivalent to <code>put()</code>, except it doesn't return the previous
         mapped value</td></tr>
     <tr><td ALIGN=RIGHT><code>ValueType</code></td>
         <td><code>addValue(KeyType key, ValueType addition)</code></td>
         <td>Only if the <code>ValueType</code> is a numeric primitive type</td></tr>
     <tr><td ALIGN=RIGHT><code>ValueType</code></td>
         <td><code>addValue(KeyType key, ValueType addition, ValueType initialValue)</code></td>
         <td>Only if the <code>ValueType</code> is a numeric primitive type</td></tr>
 </table>
 Where <code>KeyType</code> and <code>ValueType</code> are either some <i>reference types</i> (reference
 type is a declared type, or an array type, or a type variable) or <i>numeric primitive types</i>
 (<code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code> or
 <code>double</code>). <code>KeyType</code> and <code>ValueType</code> are independent in this regard: i. e. the
 <code>KeyType</code> could be <code>int</code> with the <code>ValueType</code> of <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang"><code>String</code></a> or <code>V</code>
 (a type variable) or <code>long</code>, and so on, in any combination.

 <h4><a name="method-form-matching">Method form matching</a></h4>
 <p>"A method matches a form" means that the form and the method have the same <i>signature</i>
 (as defined in the Java Language Specification, ยง8.4.2), and return type of the form is identical
 to the return type of the method, or, if the return type of the form is a reference type, it is a
 <i>subtype</i> of the return type of the method. If the method is annotated with a <a href="../../../com/koloboke/compile/MethodForm.html" title="annotation in com.koloboke.compile"><code>@MethodForm</code></a> annotation, for signature comparison, instead of the method's own name,
 the name specified by the <code>@MethodForm</code> is taken. The method might declare any exceptions
 in the <code>throws</code> clause. Method parameter <i>names</i> are <i>not</i> included in method
 signatures in the Java language, hence they shouldn't necessarily be the same in the from and the
 matching method.

 <h4><a name="type-consistency"><code>KeyType</code> and <code>ValueType</code> consistency</a></h4>
 <p><code>KeyType</code> and <code>ValueType</code> should be the same in all methods (either abstract or
 not) in the <code>@KolobokeMap</code>-annotated type, which match the above forms (and the forms
 defined below). For example, the annotated type couldn't simultaneously have methods <code>int put(K, long)</code> and <code>String replace(K, String)</code>, because according to the first method
 the <code>ValueType</code> is <code>int</code>, and according to the second method the <code>ValueType</code> is
 <code>String</code>.

 <h4><a name="model">Key and value types (<code>Map</code> model definition)</a></h4>
 <p>Hereafter in this specification and specifications of other Koloboke Compile annotations, for
 some <code>@KolobokeMap</code>-annotated type, the <code>KeyType</code> and <code>ValueType</code> appearing in
 the abstract methods of this type, which match the above forms, are called the <i>key type</i>
 and the <i>value type</i> of the annotated type.

 <h4><a name="boxing">"Boxed" and "primitive" versions of method forms for numeric primitive key
 or value types</a></h4>
 <p>If either the key type or the value type or both are some numeric primitive types, methods
 (either abstract or not) could match additional versions of the <code>put()</code>, <code>putIfAbsent()</code> or both <code>replace()</code> forms from the above list: a version with primitive
 wrapper classes in the positions of the corresponding primitive numeric <code>KeyType</code> and
 <code>ValueType</code>. For example, if the key type of the annotated type is <code>int</code> and the
 value type is <code>long</code>, it could have method <code>long put(int, long)</code>, or <code>Long put(Integer, Long)</code>, or both simultaneously. If the key type of the annotated type is <code>String</code> and the value type is <code>double</code>, it could have methods <code>double addValue(String, double)</code> and <code>boolean replace(String, Double, Double)</code>. Among the
 methods of some <code>@KolobokeMap</code>-annotated type some method forms could appear in the
 "primitive" version, some other forms - only in the "boxed" version, and some forms could appear
 in both versions. "Mixed" versions and "boxed" versions of <code>justPut()</code> and both <code>addValue()</code> forms are disallowed: <span style="text-decoration:line-through;">
 <code>long put(Integer, long)</code></span>, <span style="text-decoration:line-through;">
 <code>void justPut(String, Double)</code></span>.

 <p>A numeric primitive key or value type could even never appear as itself in the signatures and
 return types of the methods of the annotated type (but only as a wrapper class in methods
 matching the "boxed" versions of some forms): for example, a <code>@KolobokeMap</code>-annotated
 interface extending <code>Map&lt;Long, Double&gt;</code> and not defining own methods (hence inheriting
 abstract methods like <code>Double put(Long, Double)</code>, which match the "boxed" versions of the
 defined forms) still have primitive <code>long</code> key type and primitive <code>double</code> value
 type. This is important, because in the generated implementations for such types keys and/or
 values are stored as primitives, hence insertion of the <code>null</code> key or value into such map
 is not possible and always leads to <code>NullPointerException</code>. The only way to make Koloboke
 Compile to generate a map implementation that actually stores primitive wrapper objects (though
 this is a highly questionable goal) is to annotate with <code>@KolobokeMap</code> a generic abstract
 class or an interface with key or value type of a type variable, and parameterize it with
 primitive wrapper class (e. g. <code>Integer</code>) at the moment of instantiation.

 <p>Currently Koloboke Compile is able to generate only hash table-based implementations of
 annotated Map-like classes or interfaces. In the future, ability to generate other kinds of
 implementations (e. g. tree-based) might be added.

 <h4>Other method forms</h4>
 <p>In addition to the method forms specified above, a <code>KolobokeMap</code>-annotated class or
 interface could have methods (either abstract or not) matching the following forms:
 <ul>
     <li><b>Forms, prototyped by methods in interfaces from the Koloboke Collections API</b>
     <table BORDER CELLPADDING=3 CELLSPACING=1
     summary="Forms, prototyped by methods in interfaces from the Koloboke Collections API">
         <tr><th><code>KeyType</code></th><th><code>ValueType</code></th>
         <th><i>Prototyping interface</i></th></tr>

         <tr><td>A reference type</td><td>A reference type</td>
         <td><code>HashObjObjMap&lt;KeyType, ValueType&gt;</code></td></tr>

         <tr><td>A reference type</td><td>A numeric primitive type</td>
         <td><code>HashObjYyyMap&lt;KeyType&gt;</code>, where <code>Yyy</code> is a capitalized name of the value
         type, e. g. <code>HashObjIntMap&lt;KeyType&gt;</code> if the value type is
         <code>int</code></td></tr>

         <tr><td>A numeric primitive type</td><td>A reference type</td>
         <td><code>HashXxxObjMap&lt;ValueType&gt;</code>, where <code>Xxx</code> is a capitalized name of the key
         type, e. g. <code>HashLongObjMap&lt;ValueType&gt;</code> if the key type is
         <code>long</code></td></tr>

         <tr><td>A numeric primitive type</td><td>A numeric primitive type</td>
         <td><code>HashXxxYyyMap</code>, where <code>Xxx</code> is a capitalized name of the key type and
         <code>Yyy</code> is a capitalized name of the value type, e. g. <code>HashLongIntMap</code> if the
         key type is <code>long</code> and the value type is <code>int</code></td></tr>
     </table>

     Method forms have signatures and return types of the methods in the prototyping
     interface from the third column in the above table, corresponding to the kinds of key and
     value types of the <code>@KolobokeMap</code>-annotated type in the first two columns of in the
     same row.

     <p>The Koloboke Collections API comes in two different distributions: for Java 6 or 7, and
     for Java 8+, and signatures of some methods are different in the same interfaces, provided by
     different distributions. For example, the method <code>ObjObjMap.forEach(BiConsumer)</code>
     has the parameter type of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/BiConsumer.html?is-external=true" title="class or interface in java.util.function"><code>java.util.function.BiConsumer</code></a>
     in the distribution for Java 8+, and <a
     href="http://leventov.github.io/Koloboke/api/1.0/java6/com/koloboke/function/BiConsumer.html"
     ><code>com.koloboke.function.BiConsumer</code></a> in the distribution for
     Java 6 and 7. Possible method forms have signatures of the methods in that version of the
     prototyping interface, <i>which is present in the compilation classpath at the moment of
     Koloboke Compile generation</i>.

     <p>Forms, defined by methods, which are not abstract in the prototyping interface, couldn't
     be matched by abstract methods in the <code>KolobokeMap</code>-annotated class or interface, but
     if there are some non-abstract matching methods, they should be consistent with the key and
     value types of the annotated type, <a href="#type-consistency">as specified above</a>. This
     means, for example, that if the project, containing the <code>@KolobokeMap</code>-annotated type,
     depends on JDK 8 and the Koloboke Collections API distribution for Java 6 and 7 (although
     Koloboke Compile emits a warning in this case, suggesting to change the dependency to the
     Koloboke Collections API distribution for Java 8+), method <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true#forEach-java.util.function.BiConsumer-" title="class or interface in java.util"><code>Map.forEach(java.util.function.BiConsumer)</code></a> will have a default implementation (i. e. it will
     be <i>non-abstract</i>) in the <code>HashObjObjMap</code> interface, so the
     <code>@KolobokeMap</code>-annotated type couldn't declare or inherit such a method as abstract.

     <p>Since <a href="#method-form-matching">as specified above</a> a form allows a matching
     method to have reference return type to be a supertype of the return type of the form, it is
     not required from e. g. the <code>keySet()</code> method to have the return type of <code>HashObjSet&lt;KeyType&gt;</code> or <code>HashLongSet</code> (the <code>keySet()</code> return
     types in the <code>HashObjObjMap&lt;KeyType, ValueType&gt;</code> and <code>HashLongObjMap</code> interfaces,
     respectively). The <code>keySet()</code> return type could be <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util"><code>Set&lt;KeyType&gt;</code></a> or
     <code>Set&lt;Long&gt;</code>, that are supertypes of <code>HashObjSet&lt;KeyType&gt;</code> and <code>HashLongSet</code>
     respectively. This is useful, if the <code>@KolobokeMap</code>-annotated type shouldn't depend on
     the Koloboke Collections API.
     </li>

     <li><b>Method forms, missing in the <code>Map</code> interface</b>
     <table BORDER CELLPADDING=3 CELLSPACING=1
     summary="Method forms, missing in the Map interface">
         <tr><th>Return type</th><th>Signature and Description</th></tr>
         <tr><td ALIGN=RIGHT VALIGN=TOP><code>boolean</code></td><td><code>justRemove(Object key)</code><br>
             Semantically equivalent to <code>remove(Object)</code>, except instead of the previously
             mapped value it returns <code>true</code>, if the removal was successful (actually changed
             the map).
             </td></tr>
         <tr><td ALIGN=RIGHT VALIGN=TOP><code>boolean</code></td>
         <td><code>containsEntry(Object key, Object value)</code><br>
             Returns <code>true</code> if <code>remove(Object, Object)</code> invoked with the same
             arguments would find the entry and return <code>true</code>.</td></tr>
     </table>
     <br>
     </li>

     <li><b>Specializations of methods with "raw" parameters in the <code>Map</code> interface</b><br>
     Methods like <code>get()</code> and <code>remove()</code> in the <code>Map</code> interface, and
     consequently in subinterfaces (including primitive specializations) from the Koloboke
     Collections API, have the key and value parameters of <code>Object</code> type, that is a
     double-edged design decision. Along with the forms, prototyped by those methods, similar
     forms with <i>generified</i> parameter types are also allowed in
     <code>@KolobokeMap</code>-annotated types:
     <table BORDER CELLPADDING=3 CELLSPACING=1
     summary="Specializations of methods with raw parameters in the Map interface">
         <tr><th>Return type</th><th>Signature</th><th>Notes</th></tr>
         <tr><td ALIGN=RIGHT><code>ValueType</code></td><td><code>get(KeyType key)</code></td><td></td></tr>
         <tr><td ALIGN=RIGHT><code>ValueType</code></td>
             <td><code>getOrDefault(KeyType key, ValueType defaultValue)</code></td><td></td></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td>
             <td><code>containsKey(KeyType key)</code></td><td></td></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td>
             <td><code>containsValue(ValueType value)</code></td><td></td></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td>
             <td><code>containsEntry(KeyType key, ValueType value)</code></td>
             <td>Unless the key and value types are both <code>Object</code> or unbound type
             variables</td></tr>
         <tr><td ALIGN=RIGHT><code>ValueType</code></td>
             <td><code>remove(KeyType key)</code></td><td></td></tr>
         <tr><td ALIGN=RIGHT><code>ValueType</code></td>
             <td><code>removeAsYyy(KeyType key)</code></td><td>Only if the key type is a reference type
             and the value type is a numeric primitive type. <code>Yyy</code> is a capitalized name of
             the value type.</td></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td>
             <td><code>justRemove(KeyType key)</code></td>
             <td>Only if the key type is not an unbound type variable</td></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td>
             <td><code>remove(KeyType key, ValueType value)</code></td><td></td></tr>
     </table>

     <a name="raw-methods"></a>
     <p>Koloboke Compile not only permits generified versions of the
     "<code>Object</code>-parameterized" methods, but <i>effectively opts out the feature of making
     queries with arguments of unrelated types for Maps with concrete (not a type variable) key or
     value type</i>. For example, if a <code>@KolobokeMap</code>-annotated class has <code>ArrayList</code>
     key type, it may have a method <code>get(Object)</code>, but an attempt to call this method with
     <code>LinkedList</code> argument will result in <code>ClassCastException</code>, with a message like
     "LinkedList couldn't be cast to ArrayList". However, if the key type of a
     <code>@KolobokeMap</code>-annotated class or interface is a type variable, and it is <code>ArrayList</code> at the instantiation point, <code>map.get(linkedList)</code> will proceed without
     exception and may return some value, if there is a mapping with an equivalent <code>ArrayList</code> as the key in this map.
     </li>
 </ul>

 <h4>Miscellaneous requirements and permissions</h4>
 <p>The <code>@KolobokeMap</code>-annotated type could have an abstract method of the form of the
 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang"><code>Object.equals(Object)</code></a> method, only if it is a subtype of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util"><code>Map</code></a>.

 <p>The <code>@KolobokeMap</code>-annotated type could have any static methods and non-abstract
 methods with any signatures and return types, as long as they don't match any of the forms
 defined above (but if they <i>do</i> match some forms, they should have
 <a href="#type-consistency">consistent</a> signatures and return types).

 <p>The annotated type could be a nested type, but in this case it should be static and
 non-private. The annotated type couldn't be an inner or an anonymous class.

 <p>If the annotated type is an abstract class, it must have exactly one non-private constructor
 (the implicit no-argument constructor counts).

 <p>The annotated type couldn't have a <a href="../../../com/koloboke/compile/KolobokeSet.html" title="annotation in com.koloboke.compile"><code>@KolobokeSet</code></a> annotation (any type could
 either have a <code>@KolobokeMap</code> or a <code>@KolobokeSet</code> annotation, but not both).

 <h3>Generated implementation</h3>
 If the annotated type meets all requirements specified above, Koloboke Compile generates a class
 that implements the annotated type (a subclass, if the annotated type is an abstract class). If
 some requirements are not met, Koloboke Compile emits a compile-time error and an implementation
 class is not generated.

 <h4>Name</h4>
 The simple name of the implementation class is the simple name of the implemented type with
 "Koloboke" prefix. For example, if the name of a <code>@KolobokeMap</code>-annotated type is <code>MyMap</code>, the name of the implementation class is <code>KolobokeMyMap</code>. If the implemented type is
 a nested type, instead of the simple name of the implemented type, it's canonical name (excluding
 package) is used with dots replaced with underscores: <code>_</code>. For example, if a
 <code>@KolobokeMap</code>-annotated type named <code>InnerMap</code> is a nested type in a type named
 <code>Outer</code>, the name of the Koloboke Compile-generated implementation class is <code>KolobokeOuter_InnerMap</code>.

 <h4>Package</h4>
 <p>The implementation class is located in the same package, as the implemented type, and has
 package-private visibility in this package.

 <h4>Type parameters</h4>
 <p>If the <code>@KolobokeMap</code>-annotated type has type parameters, the implementation class has
 the same number of type parameters with equivalent types in the same order ("equivalence of types
 of type parameters" essentially means equivalence of their bounds).

 <h4>Semantics and behaviour</h4>
 <p>The implementation class is non-abstract. It overrides all abstract methods in the implemented
 type, and doesn't override non-abstract methods. Methods in the implementation class, overriding
 some methods in the implemented type, have contracts of the methods in interfaces from the
 Koloboke Collections API, prototyping the forms, matched by the overridden methods in the
 implemented type. If a form of an overridden method is not prototyped by methods in interfaces
 from the Koloboke Collections API (e. g. <code>justPut()</code> and <code>justRemove()</code> forms, which
 are not present in any interfaces from the Koloboke Collections API), contracts of overriding
 methods in the implementation class are specified in a "Notes" column in one of the tables above,
 where the corresponding form is defined.

 <h4><a name="underriding-warning">Method underriding requires great care</a></h4>
 <p>The implementation may call <i>any</i> (even not documented as methods forms in this document)
 non-abstract methods of the implemented type, which it would otherwise generate itself. To ensure
 that user implementations of some methods don't change semantics of Koloboke Compile-generated
 methods in some unintended way (because they call underridden methods), it is recommended to
 manually check all usages of non-abstract methods of the implemented type in the Koloboke
 Compile-generated implementation class. If it appears that behaviour of some methods indeed
 become wrong because of cross-dependencies between methods in the implemented and implementation
 classes, a possible workaround is to declare new abstract method(s) having the same parameter and
 return types as the underridden method(s) which caused undesirable semantics change of other
 methods, but with different names, and annotate them with <a href="../../../com/koloboke/compile/MethodForm.html" title="annotation in com.koloboke.compile"><code>@MethodForm("nameOfTheUnderriddenMethod"</code></a>. This makes Koloboke Compile to "remap"
 usages of the underridden methods in the generated implementation (usages, which statically
 resolve to the underridden methods, i. e. where the type of the method call
 receiver is the implemented type or the implementation type, but not a supertype of the
 implemented type) to the newly declared abstract methods as well as generate implementations for
 these methods.

 <p>No guarantee is provided on whether in the generated class such bulk methods as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true#putAll-java.util.Map-" title="class or interface in java.util"><code>Map.putAll(java.util.Map&lt;? extends K, ? extends V&gt;)</code></a>, map view's <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true#containsAll-java.util.Collection-" title="class or interface in java.util"><code>Collection.containsAll(java.util.Collection&lt;?&gt;)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true#removeAll-java.util.Collection-" title="class or interface in java.util"><code>Collection.removeAll(java.util.Collection&lt;?&gt;)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#retainAll-java.util.Collection-" title="class or interface in java.util"><code>Set.retainAll(java.util.Collection&lt;?&gt;)</code></a>, etc. are implemented via single-key query methods such as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true#put-K-V-" title="class or interface in java.util"><code>Map.put(Object, Object)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true#containsKey-java.lang.Object-" title="class or interface in java.util"><code>Map.containsKey(Object)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true#remove-java.lang.Object-" title="class or interface in java.util"><code>Map.remove(Object)</code></a> etc. or
 not. More generally, is it not specified how and if any methods of the implemented class, it's
 cursors, views, iterators and cursors of the views may call each other.

 <p><b><code>equals()</code> and <code>hashCode()</code></b><br>
 The implementation class overrides <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang"><code>Object.equals(Object)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang"><code>Object.hashCode()</code></a> if
 the implemented type is a subtype of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util"><code>Map</code></a> and the methods are abstract in the implemented
 type. If any of them is non-abstract, but inherited directly from <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang"><code>Object</code></a> (i. e. inherited
 the default implementation), it is still overridden.

 <p><b><code>toString()</code></b><br>
 The implementation class overrides <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#toString--" title="class or interface in java.lang"><code>Object.toString()</code></a> if it is abstract in the implemented
 type. If it is non-abstract, but inherited directly from <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang"><code>Object</code></a>, it is still overridden.

 <p>Contracts of the methods in the generated implementation class might be affected by additional
 annotations applied to the implemented type, see the <a href="#implementation-customizations">
 Implementation Customizations</a> section below.

 <p>The implementation class is declared <code>final</code> (not extensible).

 <p>Koloboke Compile "doesn't know" about <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> and <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html?is-external=true" title="class or interface in java.lang"><code>Cloneable</code></a> interfaces:
 it doesn't check if <code>@KolobokeMap</code>-annotated classes or interfaces implement or extend
 these interfaces, nor overrides <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang"><code>Object.clone()</code></a> or implements <code>readObject()</code> and
 <code>writeObject()</code> methods, specified by the <code>Serializable</code> interface. The
 implementation classes don't declare any fields <code>transient</code>. However,
 <code>@KolobokeMap</code>-annotated types could intercept by providing implementations for
 <code>clone()</code> or serialization methods itself.

 <p>The implementation class is not synchronized in any way. It doesn't internally use the
 intrinsic object lock of the receiver instance nor any input objects. (So it doesn't declare any
 methods <code>synchronized</code>.) Abstract <code>@KolobokeMap</code>-annotated types are free to use the
 intrinsic lock (e. g. declare some non-abstract methods <code>synchronized</code>).

 <h4><a name="constructors">Constructors</a></h4>
 <p>The implementation class has two constructors. One constructor accepts a parameter of
 the <code>int</code> type, the <i>expected size of the map being constructed</i>. Another constructor
 accepts two parameters: the first of the <code>HashConfig</code> type -- a hash configuration for the
 constructed map, the second of the <code>int</code> type, the expected size of the map. Calling the
 first constructor is equivalent to calling the second, with the default hash config passed as the first argument.

 <p>If the implemented type is an abstract class and it's non-private constructor has some
 parameters, parameters lists of both constructors of the implementation type are <i>preceded</i>
 with parameters of the same types as the parameters of the implemented type's constructor,
 and they are passed over to the implemented class constructor in a <code>super()</code> call. For
 example, if a <code>@KolobokeMap</code>-annotated abstract class has a non-private constructor with
 parameter types <code>int</code>, <code>String</code> and <code>Object</code>, parameter types of the
 constructors of the generated class have the following types: <ol>
     <li><code>int, String, Object, int (expectedSize)</code></li>
     <li><code>int, String, Object, HashConfig, int (expectedSize)</code></li>
 </ol>

 <p>If the non-private constructor of the implemented class has type parameters, equal type
 parameters are present in both constructors in the implementation class as well.

 <h3><a name="implementation-customizations">Implementation Customizations</a></h3>
 <h4><a name="mutability">Mutability</a></h4>
 <p>If the <code>@KolobokeMap</code>-annotated type is annotated with one of the annotations from the
 <a href="../../../com/koloboke/compile/mutability/package-summary.html"><code>
 com.koloboke.compile.mutability</code></a> package, Koloboke Compile generates an implementation
 with the specified <i>mutability profile</i>. If none of the annotations from this package is
 applied to a <code>@KolobokeMap</code>-annotated type, Koloboke Compile generates
 an implementation with <i>the least mutability, which supports all the abstract methods in
 an implemented type</i>. See <a
 href="../../../com/koloboke/compile/mutability/package-summary.html">the package documentation
 </a> for more information.

 <h4><a name="key-nullability">Key nullability</a></h4>
 <p>By default, if a <code>@KolobokeMap</code>-annotated type has a reference key type, Koloboke
 Compile generates an implementation that disallows insertion and querying the <code>null</code> key,
 i. e. calls like <code>map.put(null, value)</code> and <code>map.get(null)</code> on instances of such
 implementation result in <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang"><code>NullPointerException</code></a>. Koloboke Compile generates an
 implementation that allows the <code>null</code> key, only if the implemented type is annotated with
 <a href="../../../com/koloboke/compile/NullKeyAllowed.html" title="annotation in com.koloboke.compile"><code>@NullKeyAllowed</code></a>.

 <h4><a name="custom-key-equivalence">Custom key equivalence</a></h4>
 <p>By default Koloboke Compile generates a Map implementation (for a model with a <i>reference
 </i> key type) which relies on the Java built-in object equality (<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang"><code>Object.equals(Object)</code></a>
 and <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang"><code>Object.hashCode()</code></a>) for comparing keys, just as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util"><code>Map</code></a> interface specifies. But
 if the implemented type has two non-abstract methods which match <code>boolean keyEquals(KeyType, KeyType)</code> <code>int keyHashCode(KeyType)</code> forms, the generated
 implementation class relies on these methods for determining hash codes and comparing the queried
 keys. This may be used for "redefining" inefficiently implemented <code>equals()</code> and <code>hashCode()</code> for some key type, or <a
 href="../../../com/koloboke/compile/CustomKeyEquivalence.html#configurable-key-equivalence-map"
 >making key equivalence configurable</a>, or using a non-standard equivalence relationship in
 the keys domain, e. g. defining a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html?is-external=true" title="class or interface in java.util"><code>IdentityHashMap</code></a>-like type with primitive <code>int</code>
 values. See the <a href="../../../com/koloboke/compile/CustomKeyEquivalence.html" title="annotation in com.koloboke.compile"><code>@CustomKeyEquivalence</code></a> specification for more
 information.

 <h4>Choosing a hash table algorithm</h4>
 <p>See the documentation for the
 <a href="../../../com/koloboke/compile/hash/algo/openaddressing/package-summary.html">
 <code>com.koloboke.compile.hash.algo.openaddressing</code></a> package.

 <h4>Checks for concurrent modifications</h4>
 <p>By default Koloboke Compile generates a Map implementation that returns so-called <i>fail-fast
 </i> iterators (of the collection views) and cursors, and tries to identify concurrent structural
 modifications during bulk operations like <code>forEach()</code>, <code>removeIf()</code>, <code>putAll()</code>, and during bulk operations on the collections views. This is consistent with <a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html?is-external=true" title="class or interface in java.util"><code>HashMap</code></a>'s behaviour. If instances of the Koloboke Compile-generated implementation of the
 <code>@KolobokeMap</code>-annotated type are going to be accessed only via single-key queries (e. g.
 only via <code>get()</code> and <code>put()</code>), disabling concurrent modification checks by applying
 <a href="../../../com/koloboke/compile/ConcurrentModificationUnchecked.html" title="annotation in com.koloboke.compile"><code>@ConcurrentModificationUnchecked</code></a> might improve the
 implementation performance a bit.

 <h4><a name="default-value">Custom <i>default value</i> for numeric primitive value type</a></h4>
 <p>The <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util"><code>Map</code></a> interface returns <code>null</code> from <code>get()</code> method if no value mapped
 for the key is found, from <code>put()</code>, <code>putIfAbsent()</code>, <code>replace()</code> and <code>remove()</code>, if the mapping for the key didn't exist before the operation, and passes <code>null</code>
 as the argument for the lambda in <code>compute()</code>, if the mapping for the key didn't exist
 before the compute operation. In primitive specializations of these methods using <code>null</code>
 for such "no-value" purposes is not possible, because <code>null</code> is not a valid primitive
 value. In the Koloboke Collections API, the concept of <i>default value</i> is introduced to
 address this problem. In the Koloboke Collections API, the default value of the map is
 <ul>
     <li>Constant through the map instance lifetime</li>
     <li>Returned from <code>defaultValue()</code> method, e. g. <code>ObjIntMap.defaultValue()</code></li>
     <li>Configured per-factory via <code>withDefaultValue()</code> method, e. g. <code>ObjIntMapFactory.withDefaultValue(int)</code></li>
 </ul>
 The default value is also used as the initial value in the <code>ValueType addValue(KeyType key, ValueType addition)</code> method, the version of <code>addValue()</code>
 without <code>initialValue</code> provided.

 <p>By default in the Koloboke Collections implementation library and Koloboke Compile-generated
 implementations the default value is zero for all numeric primitive value types, i. e. <code>0</code>
 for <code>int</code>, <code>0.0f</code> for <code>float</code>, etc.

 <p>If the <code>@KolobokeMap</code>-annotated type has a non-abstract, non-private method of the
 <code>ValueType defaultValue()</code> signature, the Koloboke Compile-generated implementation calls
 this method whenever it needs to return "no value" or pass "no value" to the lambda argument of
 the <code>compute()</code> method. Example: <pre><code>
 &#064;KolobokeMap
 abstract class MinusOneDefaultValueObjIntMap&lt;K&gt; implements ObjIntMap&lt;K&gt; {

     static &lt;K&gt; ObjIntMap&lt;K&gt; withExpectedSize(int expectedSize) {
         return new KolobokeMinusOneDefaultValueObjIntMap&lt;K&gt;(expectedSize);
     }

     &#064;Override
     public final int defaultValue() {
         return -1;
     }
 }</code></pre></div>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/KolobokeMap.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../com/koloboke/compile/CustomKeyEquivalence.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../com/koloboke/compile/KolobokeSet.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/koloboke/compile/KolobokeMap.html" target="_top">Frames</a></li>
<li><a href="KolobokeMap.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li>Optional</li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Element</li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
