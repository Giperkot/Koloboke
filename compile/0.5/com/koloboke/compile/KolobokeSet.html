<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_74) on Wed May 25 20:59:35 BST 2016 -->
<title>KolobokeSet (Koloboke Compile Annotations 0.5)</title>
<meta name="date" content="2016-05-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KolobokeSet (Koloboke Compile Annotations 0.5)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/KolobokeSet.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../com/koloboke/compile/KolobokeMap.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../com/koloboke/compile/MethodForm.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/koloboke/compile/KolobokeSet.html" target="_top">Frames</a></li>
<li><a href="KolobokeSet.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li>Optional</li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Element</li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.koloboke.compile</div>
<h2 title="Annotation Type KolobokeSet" class="title">Annotation Type KolobokeSet</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true" title="class or interface in java.lang.annotation">@Retention</a>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true#value--" title="class or interface in java.lang.annotation">value</a>=<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html?is-external=true#SOURCE" title="class or interface in java.lang.annotation">SOURCE</a>)
 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true" title="class or interface in java.lang.annotation">@Target</a>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true#value--" title="class or interface in java.lang.annotation">value</a>=<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#TYPE" title="class or interface in java.lang.annotation">TYPE</a>)
public @interface <span class="memberNameLabel">KolobokeSet</span></pre>
<div class="block">Specifies that Koloboke Compile should generate an implementation of the annotated <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>-like class or interface.

 <h3>Requirements and permissions for <code>@KolobokeSet</code>-annotated types</h3>
 <h4><i><code>Set</code> model defining</i> method form</h4>
 <p>The annotated type must have an abstract method (either declared in the body of the
 type or inherited) <i>matching</i> (see below) the <b><code>boolean add(KeyType key)</code></b> form,
 where <code>KeyType</code> is either some <i>reference type</i> (a declared type, or an array type, or
 a type variable) or a <i>numeric primitive type</i> (<code>byte</code>, <code>char</code>, <code>short</code>,
 <code>int</code>, <code>long</code>, <code>float</code> or <code>double</code>).

 <h4><a name="set-method-form-matching">Method form matching</a></h4>
 <p>"A method matches a form" means that the form and the method have the same <i>signature</i>
 (as defined in the Java Language Specification, ยง8.4.2), and return type of the form is identical
 to the return type of the method, or, if the return type of the form is a reference type, it is a
 <i>subtype</i> of the return type of the method. If the method is annotated with a <a href="../../../com/koloboke/compile/MethodForm.html" title="annotation in com.koloboke.compile"><code>@MethodForm</code></a> annotation, for signature comparison, instead of the method's own name,
 the name specified by the <code>@MethodForm</code> is taken. The method might declare any exceptions
 in the <code>throws</code> clause. Method parameter <i>names</i> are <i>not</i> included in method
 signatures in the Java language, hence they shouldn't necessarily be the same in the from and the
 matching method.

 <h4><a name="set-type-consistency"><code>KeyType</code> consistency</a></h4>
 <p><code>KeyType</code> should be the same in all methods (either abstract or not) in the
 <code>@KolobokeSet</code>-annotated type, which match the above form and the forms defined below. For
 example, the annotated type couldn't simultaneously have methods <code>boolean add(K)</code> and
 <code>boolean contains(String)</code>, because according to the first method the <code>KeyType</code> is
 <code>K</code> (a type variable), and according to the second method the <code>KeyType</code> is
 <code>String</code>.

 <h4>Key type(<code>Set</code> model definition)</h4>
 <p>Hereafter in this specification and specifications of other Koloboke Compile annotations, for
 some <code>@KolobokeSet</code>-annotated type, the <code>KeyType</code> appearing in the abstract method of
 this type, which match the above form, is called the <i>key type</i> of the annotated type.

 <h4>"Boxed" and "primitive" versions of the <code>add()</code> method form for numeric primitive key
 type</h4>
 <p>If the key type is a numeric primitive type, a method (either abstract or not) could match
 additional version of the <code>add()</code> form: a version with primitive wrapper classes as the
 <code>key</code> parameter. For example, if the key type of the annotated type is <code>int</code>, it
 could have method <code>boolean add(int)</code>, or <code>boolean add(Integer)</code>, or both
 simultaneously.

 <p>A numeric primitive key type could even never appear as itself in the signatures and
 return types of the methods of the annotated type (but only as a wrapper class in methods
 matching the "boxed" versions of some forms): for example, a <code>@KolobokeSet</code>-annotated
 interface extending <code>Set&lt;Long&gt;</code> and not defining own methods (hence inheriting
 abstract methods like <code>boolean put(Long)</code>, which match the "boxed" version of the
 <code>add()</code> form) still have primitive <code>long</code> key type. This is important, because in the
 generated implementations for such types keys are stored as primitives, hence insertion of the
 <code>null</code> key into such set is not possible and always leads to <code>NullPointerException</code>.
 The only way to make Koloboke Compile to generate a set implementation that actually stores
 primitive wrapper objects (though this is a highly questionable goal) is to annotate with
 <code>@KolobokeSet</code> a generic abstract class or an interface with key type of a type variable,
 and parameterize it with primitive wrapper class (e. g. <code>Integer</code>) at the moment of
 instantiation.

 <p>Currently Koloboke Compile is able to generate only hash table-based implementations of
 annotated Set-like classes or interfaces. In the future, ability to generate other kinds of
 implementations (e. g. tree-based) might be added.

 <h4>Other method forms</h4>
 <p>In addition to the <code>add()</code> method form, a <code>KolobokeSet</code>-annotated class or
 interface could have methods (either abstract or not) matching the following forms:
 <ul>
     <li><b>Forms, prototyped by methods in interfaces from the Koloboke Collections API</b><br>
     If the key type is a reference type, the prototyping interface is <a href="http://leventov.github.io/Koloboke/api/1.0/java8/com/koloboke/collect/set/hash/HashObjSet.html?is-external=true" title="class or interface in com.koloboke.collect.set.hash"><code>HashObjSet&lt;KeyType&gt;</code></a>. If the key type is a numeric primitive type, the prototyping
     interface is <code>HashXxxSet</code>, where is a capitalized name of the key type, e. g. <a href="http://leventov.github.io/Koloboke/api/1.0/java8/com/koloboke/collect/set/hash/HashIntSet.html?is-external=true" title="class or interface in com.koloboke.collect.set.hash"><code>HashIntSet</code></a> if the key type is <code>int</code>. Method forms have signatures and return types of
     the methods in the prototyping interface.

     <p>The Koloboke Collections API comes in two different distributions: for Java 6 or 7, and
     for Java 8+, and signatures of some methods are different in the same interfaces, provided by
     different distributions. For example, the method <a href="http://leventov.github.io/Koloboke/api/1.0/java8/com/koloboke/collect/ObjCollection.html?is-external=true#forEach-com.koloboke.function.Consumer-" title="class or interface in com.koloboke.collect"><code>ObjCollection.forEach(Consumer)</code></a> has the
     parameter type of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function"><code>java.util.function.Consumer</code></a> in the
     distribution for Java 8+, and <a
     href="http://leventov.github.io/Koloboke/api/1.0/java6/com/koloboke/function/Consumer.html">
     <code>com.koloboke.function.Consumer</code></a> in the distribution for Java 6 and 7. Possible
     method forms have signatures of the methods in that version of the prototyping interface,
     <i>which is present in the compilation classpath at the moment of Koloboke Compile generation
     </i>.

     <p>Forms, defined by methods, which are not abstract in the prototyping interface, couldn't
     be matched by abstract methods in the <code>KolobokeSet</code>-annotated class or interface, but
     if there are some non-abstract matching methods, they should be consistent with the key and
     value types of the annotated type, <a href="#set-type-consistency">as specified above</a>.
     This means, for example, that if the project, containing the <code>@KolobokeSet</code>-annotated
     type, depends on JDK 8 and the Koloboke Collections API distribution for Java 6 and 7
     (although Koloboke Compile emits a warning in this case, suggesting to change the dependency
     to the Koloboke Collections API distribution for Java 8+), method <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true#forEach-java.util.function.Consumer-" title="class or interface in java.lang"><code>Iterable.forEach(java.util.function.Consumer)</code></a> will have a default implementation (i. e. it will
     be <i>non-abstract</i>) in the <a href="http://leventov.github.io/Koloboke/api/1.0/java8/com/koloboke/collect/set/hash/HashObjSet.html?is-external=true" title="class or interface in com.koloboke.collect.set.hash"><code>HashObjSet</code></a> interface, so the
     <code>@KolobokeSet</code>-annotated type couldn't declare or inherit such a method as abstract.

     <p>The Koloboke Collections API distribution for Java 8+ doesn't currently declare
     <code>stream()</code> and <code>spliterator()</code> methods as abstract, so they couldn't be abstract
     in <code>@KolobokeSet</code>-annotated types as well.
     </li>

     <li><b>Specializations of methods with "raw" parameters in the <code>Set</code> interface</b><br>
     Methods <code>contains()</code> and <code>remove()</code> in the <code>Set</code> interface, and
     consequently in subinterfaces (including primitive specializations) from the Koloboke
     Collections API, have the key parameter of <code>Object</code> type, that is a double-edged design
     decision. Along with the forms, prototyped by those methods, similar
     forms with <i>generified</i> parameter type are also allowed in
     <code>@KolobokeSet</code>-annotated types:
     <table BORDER CELLPADDING=3 CELLSPACING=1
     summary="Specializations of methods with raw parameters in the Set interface">
         <tr><th>Return type</th><th>Signature</th></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td><td><code>contains(KeyType key)</code></td></tr>
         <tr><td ALIGN=RIGHT><code>boolean</code></td><td><code>remove(KeyType key)</code></td></tr>
     </table>

     <p>Koloboke Compile not only permits generified versions of the
     "<code>Object</code>-parameterized" methods, but <i>effectively opts out the feature of making
     queries with arguments of unrelated types for Sets with concrete (not a type variable) key
     type</i>. For example, if a <code>@KolobokeSet</code>-annotated class has <code>ArrayList</code>
     key type, it may have a method <code>contains(Object)</code>, but an attempt to call this method
     with <code>LinkedList</code> argument will result in <code>ClassCastException</code>, with a message
     like "LinkedList couldn't be cast to ArrayList". However, if the key type of a
     <code>@KolobokeSet</code>-annotated class or interface is a type variable, and it is <code>ArrayList</code> at the instantiation point, <code>set.contains(linkedList)</code> will proceed without
     exception and may return <code>true</code>, if there is an equivalent <code>ArrayList</code> key in
     this set.
     </li>
 </ul>

 <h4>Miscellaneous requirements and permissions</h4>
 <p>The <code>@KolobokeSet</code>-annotated type could have an abstract method of the form of the
 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang"><code>Object.equals(Object)</code></a> method, only if it is a subtype of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util"><code>Set</code></a>.

 <p>The <code>@KolobokeSet</code>-annotated type could have any static methods and non-abstract
 methods with any signatures and return types, as long as they don't match any of the forms
 defined above (but if they <i>do</i> match some forms, they should have
 <a href="#set-type-consistency">consistent</a> signatures and return types).

 <p>The annotated type could be a nested type, but in this case it should be static and
 non-private. The annotated type couldn't be an inner or an anonymous class.

 <p>If the annotated type is an abstract class, it must have exactly one non-private constructor
 (the implicit no-argument constructor counts).

 <p>The annotated type couldn't have a <a href="../../../com/koloboke/compile/KolobokeMap.html" title="annotation in com.koloboke.compile"><code>@KolobokeMap</code></a> annotation (any type could
 either have a <code>@KolobokeSet</code> or a <code>@KolobokeMap</code> annotation, but not both).

 <h3>Generated implementation</h3>
 If the annotated type meets all requirements specified above, Koloboke Compile generates a class
 that implements the annotated type (a subclass, if the annotated type is an abstract class). If
 some requirements are not met, Koloboke Compile emits a compile-time error and an implementation
 class is not generated.

 <h4>Name</h4>
 The simple name of the implementation class is the simple name of the implemented type with
 "Koloboke" prefix. For example, if the name of a <code>@KolobokeSet</code>-annotated type is <code>MySet</code>, the name of the implementation class is <code>KolobokeMySet</code>. If the implemented type is
 a nested type, instead of the simple name of the implemented type, it's canonical name (excluding
 package) is used with dots replaced with underscores: <code>_</code>. For example, if a
 <code>@KolobokeSet</code>-annotated type named <code>InnerSet</code> is a nested type in a type named
 <code>Outer</code>, the name of the Koloboke Compile-generated implementation class is <code>KolobokeOuter_InnerSet</code>.

 <h4>Package</h4>
 <p>The implementation class is located in the same package, as the implemented type, and has
 package-private visibility in this package.

 <h4>Type parameters</h4>
 <p>If the <code>@KolobokeSet</code>-annotated type has type parameters, the implementation class has
 the same number of type parameters with equivalent types in the same order ("equivalence of types
 of type parameters" essentially means equivalence of their bounds).

 <h4>Semantics and behaviour</h4>
 <p>The implementation class is non-abstract. It overrides all abstract methods in the implemented
 type, and doesn't override non-abstract methods. Methods in the implementation class, overriding
 some methods in the implemented type, have contracts of the methods in interfaces from the
 Koloboke Collections API, prototyping the forms, matched by the overridden methods in the
 implemented type.

 <h4>Method underriding requires great care</h4>
 <p>The implementation may call <i>any</i> (even not documented as methods forms in this document)
 non-abstract methods of the implemented type, which it would otherwise generate itself. To ensure
 that user implementations of some methods don't change semantics of Koloboke Compile-generated
 methods in some unintended way (because they call underridden methods), it is recommended to
 manually check all usages of non-abstract methods of the implemented type in the Koloboke
 Compile-generated implementation class. If it appears that behaviour of some methods indeed
 become wrong because of cross-dependencies between methods in the implemented and implementation
 classes, a possible workaround is to declare new abstract method(s) having the same parameter and
 return types as the underridden method(s) which caused undesirable semantics change of other
 methods, but with different names, and annotate them with <a href="../../../com/koloboke/compile/MethodForm.html" title="annotation in com.koloboke.compile"><code>@MethodForm("nameOfTheUnderriddenMethod"</code></a>. This makes Koloboke Compile to replace
 usages of the underridden methods in the generated implementation (usages, which statically
 resolve to the underridden methods, i. e. where the type of the method call
 receiver is the implemented type or the implementation type, but not a supertype of the
 implemented type) with the newly declared abstract methods as well as generate implementations
 for these methods.

 <p>No guarantee is provided on whether in the generated class such bulk methods as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#containsAll-java.util.Collection-" title="class or interface in java.util"><code>Set.containsAll(java.util.Collection&lt;?&gt;)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#addAll-java.util.Collection-" title="class or interface in java.util"><code>Set.addAll(java.util.Collection&lt;? extends E&gt;)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#removeAll-java.util.Collection-" title="class or interface in java.util"><code>Set.removeAll(java.util.Collection&lt;?&gt;)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#retainAll-java.util.Collection-" title="class or interface in java.util"><code>Set.retainAll(java.util.Collection&lt;?&gt;)</code></a>, etc. are
 implemented via single-key query methods such as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#contains-java.lang.Object-" title="class or interface in java.util"><code>Set.contains(Object)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#add-E-" title="class or interface in java.util"><code>Set.add(Object)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true#remove-java.lang.Object-" title="class or interface in java.util"><code>Set.remove(Object)</code></a> etc. or not. More generally, is it not specified how
 and if any methods of the implemented class, it's iterators and cursors may call each other.

 <p><b><code>equals()</code> and <code>hashCode()</code></b><br>
 The implementation class overrides <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang"><code>Object.equals(Object)</code></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang"><code>Object.hashCode()</code></a> if
 the implemented type is a subtype of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util"><code>Set</code></a> and the methods are abstract in the implemented
 type. If any of them is non-abstract, but inherited directly from <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang"><code>Object</code></a> (i. e. inherited
 the default implementation), it is still overridden.

 <p><b><code>toString()</code></b><br>
 The implementation class overrides <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#toString--" title="class or interface in java.lang"><code>Object.toString()</code></a> if it is abstract in the implemented
 type. If it is non-abstract, but inherited directly from <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang"><code>Object</code></a>, it is still overridden.

 <p>Contracts of the methods in the generated implementation class might be affected by additional
 annotations applied to the implemented type, see the
 <a href="#set-implementation-customizations">Implementation Customizations</a> section below.

 <p>The implementation class is declared <code>final</code> (not extensible).

 <p>Koloboke Compile "doesn't know" about <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> and <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html?is-external=true" title="class or interface in java.lang"><code>Cloneable</code></a> interfaces:
 it doesn't check if <code>@KolobokeSet</code>-annotated classes or interfaces implement or extend
 these interfaces, nor overrides <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang"><code>Object.clone()</code></a> or implements <code>readObject()</code> and
 <code>writeObject()</code> methods, specified by the <code>Serializable</code> interface. The
 implementation classes don't declare any fields <code>transient</code>. However,
 <code>@KolobokeSet</code>-annotated types could intercept by providing implementations for
 <code>clone()</code> or serialization methods itself.

 <p>The implementation class is not synchronized in any way. It doesn't internally use the
 intrinsic object lock of the receiver instance nor any input objects. (So it doesn't declare any
 methods <code>synchronized</code>.) Abstract <code>@KolobokeSet</code>-annotated types are free to use the
 intrinsic lock (e. g. declare some non-abstract methods <code>synchronized</code>).

 <h4>Constructors</h4>
 <p>The implementation class has two constructors. One constructor accepts a parameter of
 the <code>int</code> type, the <i>expected size of the set being constructed</i>. Another constructor
 accepts two parameters: the first of the <a href="http://leventov.github.io/Koloboke/api/1.0/java8/com/koloboke/collect/hash/HashConfig.html?is-external=true" title="class or interface in com.koloboke.collect.hash"><code>HashConfig</code></a> type -- a hash configuration for the
 constructed set, the second of the <code>int</code> type, the expected size of the set. Calling the
 first constructor is equivalent to calling the second, with the <a href="http://leventov.github.io/Koloboke/api/1.0/java8/com/koloboke/collect/hash/HashConfig.html?is-external=true#getDefault--" title="class or interface in com.koloboke.collect.hash">default hash config</a> passed as the first argument.

 <p>If the implemented type is an abstract class and it's non-private constructor has some
 parameters, parameters lists of both constructors of the implementation type are <i>preceded</i>
 with parameters of the same types as the parameters of the implemented type's constructor,
 and they are passed over to the implemented class constructor in a <code>super()</code> call. For
 example, if a <code>@KolobokeSet</code>-annotated abstract class has a non-private constructor with
 parameter types <code>int</code>, <code>String</code> and <code>Object</code>, parameter types of the
 constructors of the generated class have the following types: <ol>
     <li><code>int, String, Object, int (expectedSize)</code></li>
     <li><code>int, String, Object, HashConfig, int (expectedSize)</code></li>
 </ol>

 <p>If the non-private constructor of the implemented class has type parameters, equal type
 parameters are present in both constructors in the implementation class as well.

 <h3><a name="set-implementation-customizations">Implementation Customizations</a></h3>
 <h4><a name="set-mutability">Mutability</a></h4>
 <p>If the <code>@KolobokeSet</code>-annotated type is annotated with one of the annotations from the
 <a href="../../../com/koloboke/compile/mutability/package-summary.html"><code>
 com.koloboke.compile.mutability</code></a> package, Koloboke Compile generates an implementation
 with the specified <i>mutability profile</i>. If none of the annotations from this package is
 applied to a <code>@KolobokeSet</code>-annotated type, Koloboke Compile generates
 an implementation with <i>the least mutability, which supports all the abstract methods in
 an implemented type</i>. See <a
 href="../../../com/koloboke/compile/mutability/package-summary.html">the package documentation
 </a> for more information.

 <h4><a name="set-key-nullability">Key nullability</a></h4>
 <p>By default, if a <code>@KolobokeSet</code>-annotated type has a reference key type, Koloboke
 Compile generates an implementation that disallows insertion and querying the <code>null</code> key,
 i. e. calls like <code>set.add(null)</code>, <code>set.remove(null)</code> and <code>set.contains(null)</code>
 on instances of such implementation result in <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang"><code>NullPointerException</code></a>. Koloboke Compile
 generates an implementation that allows the <code>null</code> key, only if the implemented type is
 annotated with <a href="../../../com/koloboke/compile/NullKeyAllowed.html" title="annotation in com.koloboke.compile"><code>@NullKeyAllowed</code></a>.

 <h4><a name="set-custom-key-equivalence">Custom key equivalence</a></h4>
 <p>By default Koloboke Compile generates a Set implementation (for a model with a <i>reference
 </i> key type) which relies on the Java built-in object equality (<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang"><code>Object.equals(Object)</code></a>
 and <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang"><code>Object.hashCode()</code></a>) for comparing keys, just as <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util"><code>Set</code></a> interface specifies. But
 if the implemented type has two non-abstract methods which match <code>boolean keyEquals(KeyType, KeyType)</code> <code>int keyHashCode(KeyType)</code> forms, the generated
 implementation class relies on these methods for determining hash codes and comparing the queried
 keys. This may be used for "redefining" inefficiently implemented <code>equals()</code> and <code>hashCode()</code> for some key type, or <a
 href="../../../com/koloboke/compile/CustomKeyEquivalence.html#configurable-key-equivalence-map"
 >making key equivalence configurable</a>, or using a non-standard equivalence relationship in
 the keys domain, e. g. defining a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html?is-external=true" title="class or interface in java.util"><code>IdentityHashMap</code></a>-like set type. See the <a href="../../../com/koloboke/compile/CustomKeyEquivalence.html" title="annotation in com.koloboke.compile"><code>@CustomKeyEquivalence</code></a> specification for more information.

 <h4>Choosing a hash table algorithm</h4>
 <p>See the documentation for the
 <a href="../../../com/koloboke/compile/hash/algo/openaddressing/package-summary.html">
 <code>com.koloboke.compile.hash.algo.openaddressing</code></a> package.

 <h4>Checks for concurrent modifications</h4>
 <p>By default Koloboke Compile generates a Set implementation that returns so-called <i>fail-fast
 </i> iterators and cursors, and tries to identify concurrent structural modifications during bulk
 operations like <code>forEach()</code>, <code>removeIf()</code>, <code>containsAll()</code>, <code>addAll()</code>,
 etc. This is consistent with <a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html?is-external=true" title="class or interface in java.util"><code>HashSet</code></a>'s behaviour. If instances of the Koloboke
 Compile-generated implementation of the <code>@KolobokeSet</code>-annotated type are going to be
 accessed only via single-key queries (e. g. only via <code>add()</code> and <code>contains()</code>),
 disabling concurrent modification checks by applying <a href="../../../com/koloboke/compile/ConcurrentModificationUnchecked.html" title="annotation in com.koloboke.compile"><code>@ConcurrentModificationUnchecked</code></a> might improve the
 implementation performance a bit.</div>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/KolobokeSet.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../com/koloboke/compile/KolobokeMap.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../com/koloboke/compile/MethodForm.html" title="annotation in com.koloboke.compile"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/koloboke/compile/KolobokeSet.html" target="_top">Frames</a></li>
<li><a href="KolobokeSet.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li>Optional</li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Element</li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
